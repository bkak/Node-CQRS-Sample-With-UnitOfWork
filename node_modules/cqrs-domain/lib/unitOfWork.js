var async = require('async')
    , EventEmitter2 = require('eventemitter2').EventEmitter2
    , eventStore = require('eventstore')
    , _ = require('lodash')
    , eventEmitter = require('./eventEmitter')


var UOW = function(){
    //this.CommandQueue = [];
        this.DirtyAggregateRoots =[];
        this.CorelationId = "";
    this.eventStoreStream ;
    this.eventStore;
    this.options = {snapshotThreshold:10}
    this.CommitAllAggregates = function(){
        var i=0;
        while(i < this.DirtyAggregateRoots.length)
        {
            var dar = this.DirtyAggregateRoots[i];
            this.commit(dar, dar.aggregate, this.eventStoreStream, function(){
                i = i+1;
            });
        }
    },
    this.RollbackAllAggregates = function(err){
        eventEmitter.emit('DomainExceptionInternal' ,  err);
        var i =0;
        while(i < this.DirtyAggregateRoots.length)
        {
            var cmd = this.DirtyAggregateRoots[i];
            eventEmitter.emit('handled:' + cmd.command, cmd.payload.id, cmd);
            i = i +1;
        }
        this.DirtyAggregateRoots = [];

    }
    this.commit = function(cmd, aggregate, stream, callback) {
        var self = this;
        async.concat(aggregate.uncommittedEvents, function(evt, next) {
                evt.commandId = cmd.id;
                if (cmd.head) {
                    evt.head = _.extend(_.clone(cmd.head), evt.head);
                }

                self.eventStore.getNewIdFromStorage(function(err, id) {
                    evt.id = id;
                    stream.addEvent(evt);
                    next(err);
                });
            },
            // final
            function(err) {
                if (!err) {
                    stream.commit(function(err) {
                        // Check if snapshotting is needed.
                        if (stream.events.length >= self.options.snapshotThreshold) {
                            self.eventStore.createSnapshot(stream.streamId, stream.currentRevision(), aggregate.toJSON());
                        }
                    });
                }
                callback(null);
            });
    }
    this.AREventsHasAnySagaHandlers = function(aggregate){
        //todo check if uncommitted events have listeners
        var hasSaga = false;
        _.forEach(aggregate.uncommittedEvents,function(evt){
            var len = eventEmitter.listeners('event_inmemory:' + evt.event).length;
            console.log('event listeners : ' + len);
            if(len > 0) {
                hasSaga = true;
                return;
            }
            else  hasSaga = hasSaga ? true : false;
        });
        return hasSaga;
    }
};
    UOW.prototype.Initialize = function(corelationId, command, commandDispatcher, callback)
    {
        command.IsProcessed = false;
        this.CorelationId = corelationId;
        this.CommandDispatcher = commandDispatcher;
        this.HandleCommand(command, callback);
    },

    UOW.prototype.HandleCommand = function(cmd,  callback)
    {
        if(!cmd.IsProcessed) {
            //can give to command dispatcher also
            this.CommandDispatcher.dispatch(this, cmd, function(){
                cmd.IsProcessed = true;
                callback();
            });
            //eventEmitter.emit('handle:' + cmd.command + ":" + this.CorelationId, this.CorelationId, cmd, this);
        }
    },
    UOW.prototype.RegisterDirty = function( cmd, aggregate, stream, eventstore){
        cmd.aggregate = aggregate;
        this.eventStoreStream = stream;
        this.eventStore = eventstore;
        var self = this;

            this.DirtyAggregateRoots.push(cmd);
            if(this.AREventsHasAnySagaHandlers(aggregate)){
                async.concat(aggregate.uncommittedEvents, function(evt, next) {
                    evt.commandId = cmd.id;
                    if (cmd.head) {
                        evt.head = _.extend(_.clone(cmd.head), evt.head);
                    }
                    eventEmitter.emit('event_inmemory:' + evt.event, evt, self);
                })
            }
            else{
                this.CommitAllAggregates();
            }


    },
    UOW.prototype.ExceptionEncountered = function(err)
    {
        this.RollbackAllAggregates(err);
    }



_.extend(new EventEmitter2({
    wildcard: true,
    delimiter: ':',
    maxListeners: 1000 // default would be 10!
}),UOW);

module.exports = UOW;




