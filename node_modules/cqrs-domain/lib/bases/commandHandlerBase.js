var eventEmitter = require('../eventEmitter')
  , async = require('async')
  , _ = require('lodash');

var CommandHandler = {};

CommandHandler.prototype = {

    defaultHandle: function(id, cmd) {

        var self = this;

        async.waterfall([

            // load aggregate
            function(callback) {
                self.loadAggregate(id, callback);
            },

            // reject command if aggregate has already been destroyed
            function(aggregate, stream, callback) {
                if(aggregate.get('destroyed')) {
                    return callback('Aggregate has already been destroyed!');
                }
                
                callback(null, aggregate, stream);
            },

            // check revision
            function(aggregate, stream, callback) {
                self.checkRevision(cmd, aggregate.get('revision'), function(err) {
                    callback(err, aggregate, stream);
                });
            },

            // call validate command
            function(aggregate, stream, callback) {
                self.validate(cmd.command, cmd.payload, function(err) {
                    callback(err, aggregate, stream);
                });
            },

            // call command function on aggregate
            function( aggregate, stream, callback) {
                try{
                    aggregate[cmd.command](cmd.payload, function(err) {
                        callback(err, aggregate, stream);
                    });
                }
                catch(err)
                {
                    callback(err);
                }
            },

            // commit the new events
            function(aggregate, stream, callback) {
                //self.commit(cmd, aggregate, stream);
                //bhoomi
                self.registerDirty (cmd, aggregate, stream, this.eventStore);
                callback(null);
            }
        ],

        // finally publish commandRejected event on error
        function(err) {
            if (err) {
                if(err.name =="DomainException")
                {
                    self.exceptionEncountered(err);
                }
                else{
                     eventEmitter.emit('commandRejected', cmd, err);
                }
            }
            console.log("emit handled command event: " + cmd.id + ", " + cmd.command);
            eventEmitter.emit('handled:' + cmd.command, cmd.payload.id, cmd);
        });
    },
    registerDirty : function(cmd, aggregate, stream)
    {
        this.UOW.RegisterDirty(cmd, aggregate, stream, this.eventStore);
    },
    exceptionEncountered : function(err)
    {
        this.UOW.ExceptionEncountered(err);
    },

    validate: function(ruleName, data, callback) {
        if(this.validationRules && this.validationRules[ruleName]) {
            this.validationRules[ruleName].validate(data, function(err) {
                if (err) {
                    var keys = _.toArray(err);
                    _.each(keys, function(key) {
                        key.type = 'validationRule';
                    });
                    callback(keys);
                } else {
                    callback(null);
                }
            });
        } else {
            callback(null);
        }
    },

    handle: function(id, cmd) {
        if (this[cmd.command]) {
            this[cmd.command](id, cmd);
        } else {
            this.defaultHandle(id, cmd);
        }
    },

    SetUOW : function(uow)
    {
       this.UOW  = uow;
    },
    loadAggregate: function(id, callback) {
        var aggregate = new this.Aggregate(id);
        this.eventStore.getFromSnapshot(id, function(err, snapshot, stream) {
            async.map(stream.events, function(evt, next) {
                next(null, evt.payload);
            }, function(err, events) {
                aggregate.loadFromHistory(snapshot.data, events);
                callback(null, aggregate, stream); 
            });
        });
    },

    getNewId: function(callback) {
        this.eventStore.getNewIdFromStorage(callback);
    },

    checkRevision: function(cmd, aggRev, callback) {
        if(!cmd.head || cmd.head.revision === undefined || 
            (cmd.head && cmd.head.revision === aggRev)) {
            return callback(null);
        }

        callback('Concurrency exception. Actual ' + 
            cmd.head.revision + ' expected ' + aggRev);
    },

    configure: function(fn) {
        fn.call(this);
        return this;
    }, 

    use: function(module) {
        if (!module) return;
    
        if (module.getFromSnapshot) {
            this.eventStore = module;
        }
    }

};

module.exports = {

    extend: function(obj) {
        return _.extend(_.clone(CommandHandler.prototype), obj);
    }

};